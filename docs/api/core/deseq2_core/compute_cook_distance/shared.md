| ID | Name | Type | Shape | Description | Computed by | Sent to |
|---|---|---|---|---|---|---|
| 1 | use\_lvl | bool | $()$ | Whether or not to use the levels of the design matrix to compute the trimmed mean. If use\_lvl is $\texttt{True}$, then one trimmed mean of the normed counts will be computed for each gene and for each level of the design matrix (that is the trimmed mean will be performed on the samples corresponding to the same level of the design matrix across all centers). If use\_lvl is $\texttt{False}$, then one trimmed mean of the normed counts will be computed for each gene and for all samples. This parameter is set to $\texttt{True}$ if there is at least one level of the design matrix with more than 3 replicates across all centers, and to $\texttt{False}$ otherwise. | Each center | Server |
| 1 | $l \in \mathcal{L}_{\geq 3}$ | dict |  | Let $\mathcal{L}_{\geq 3}$ bet the set of levels $1 \leq l \leq L$ of the design matrix with at least $3$ replicates across all centers. Let $\mathcal{I}_{k,l}$ denote the set of sample indices $1 \leq i \leq n_k$ in center $k$ whose line in the design corresponds to level $l$. Dictionary with two keys. <br> "max\_values", which is a numpy array of shape $G$ containing, for each gene $g$, the maximum value of the center normed counts for $g$ on samples in $\mathcal{I}_{k,l}$, denoted with $(Z^{\texttt{max}}_{g,l})^{(k)}$. <br> "min\_values", which is a numpy array of shape $G$ containing, for each gene $g$, the minimum value of the center normed counts for $g$ on samples in $\mathcal{I}_{k,l}$, denoted with $(Z^{\texttt{min}}_{g,l})^{(k)}$. | Each center | Server |
| 2 | $l \in \mathcal{L}_{\geq 3}$ | dict |  | Dictionary with two keys. <br> "upper\_bounds\_thresholds" is a numpy array of shape $(G, 2)$. For each gene $g$ and for each ratio $r \in \{r_{\texttt{trim}}, 1 - r_{\texttt{trim}}\}$, will contain an upper bound of the $r$-quantile value of the normed counts of gene $g$ across samples in level $l$. Initialized for both ratios as the maximum of the normed counts of gene $g$ across all samples in level $l$, computed as $\max_k (Z^{\texttt{max}}_{g,l})^{(k)}$. <br> "lower\_bounds\_thresholds" is a numpy array of shape $(G, 2)$. For each gene $g$ and for each ratio $r \in \{r_{\texttt{trim}}, 1 - r_{\texttt{trim}}\}$, will contain a lower bound of the $r$-quantile value of the normed counts of gene $g$ across samples in level $l$. Initialized for both ratios as the minimum of the normed counts of gene $g$ across all samples in level $l$, computed as $\min_k (Z^{\texttt{min}}_{g,l})^{(k)}$. | Server | Center |
| 2 | use\_lvl | bool | $()$ | Whether or not to use the levels of the design matrix to compute the trimmed mean. Passed on without modification. | Server | Center |
| 3 | use\_lvl | bool | $()$ | Whether or not to use the levels of the design matrix to compute the trimmed mean. Passed on without modification. | Each center | Server |
| 3 | $l \in \mathcal{L}_{\geq 3}$ | dict |  | Dictionary with the following keys. <br> "num\_strictly\_above" is a numpy array of shape $(G, 2)$. For each gene $g$ and each ratio $r$, contains the number of samples in the center and in the level whose normed counts value for gene $g$ is strictly above the average of the upper and lower  bounds on the $r$-quantile value of gene $g$. <br> "upper\_bounds\_thresholds" is a numpy array of shape $(G, 2)$, simply passed on from the previous state. <br> "lower\_bounds\_thresholds" is a numpy array of shape $(G, 2)$ simply passed on from the previous state. <br> "n\_samples" is the number of samples in level $l$ and center $k$. <br> "trim\_ratio" is the trim ration, defining the upper and lower ratios whose quantile we want to compute. Denoted with $r_{\texttt{trim}}$, equal to $0.125$. | Each center | Server |
| 4 | use\_lvl | bool | $()$ | Whether or not to use the levels of the design matrix to compute the trimmed mean. Passed on without modification. | Server | Center |
| 4 | $l \in \mathcal{L}_{\geq 3}$ | dict |  | Dictionary with two keys. <br> "upper\_bounds\_thresholds" is a numpy array of shape $(G, 2)$. For each gene $g$ and for each ratio $r \in \{r_{\texttt{trim}}, 1 - r_{\texttt{trim}}\}$, contains an updated upper bound of the $r$-quantile value of the normed counts of gene $g$ across samples in level $l$. For a given gene $g$ and $r$-quantile, it is updated as either its previous value or the average of the previous upper and lower bounds across samples in level $l$, depending on the number of samples in the level whose normed counts value is strictly above this average. This number of samples can be computed from the previous shared states. <br> "lower\_bounds\_thresholds" is a numpy array of shape $(G, 2)$. For each gene $g$ and for each ratio $r \in \{r_{\texttt{trim}}, 1 - r_{\texttt{trim}}\}$, contains an updated lower bound of the $r$-quantile value of the normed counts of gene $g$ across samples in level $l$. For a given gene $g$ and $r$-quantile, it is updated as either its previous value or the average of the previous upper and lower bounds across samples in level $l$, depending on the number of samples in the level whose normed counts value is strictly above this average. This number of samples can be computed from the previous shared states. | Server | Center |
| 5 | use\_lvl | bool | $()$ | Whether or not to use the levels of the design matrix to compute the trimmed mean. Passed on without modification. | Each center | Server |
| 5 | $l \in \mathcal{L}_{\geq 3}$ | dict |  | Dictionary with the following keys. <br> "trimmed\_local\_sum" is a numpy array of shape $(G,)$. For each gene $g$ and each ration $r \in \{r_{\texttt{trim}}, 1 - r_{\texttt{trim}}\}$, we approximate the $r$-quantile by taking the average of the running upper and lower bounds. The trimmed local sum is computed as the sum of the normed counts across all samples in level $l$ and center $k$, whose value is strictly above the approximation of the $r_{\texttt{trim}}$-quantile and less or equal to the approximation of the $1-r_{\texttt{trim}}$ quantile. <br> "n\_samples" is the number of samples in level $l$ and center $k$. <br> "num\_strictly\_above" is a numpy array of shape $(G, 2)$. For each gene $g$ and each ratio $r$, contains the number of samples in the center and in the level whose normed counts value for gene $g$ is strictly above the approximation of the $r$-quantile. <br> "upper\_bounds\_thresholds" is a numpy array of shape $(G, 2)$, simply passed on from the previous state. <br> "lower\_bounds\_thresholds" is a numpy array of shape $(G, 2)$ simply passed on from the previous state. "trim\_ratio", equal to $0.125$. | Each center | Server |
| 6 | trimmed\_mean\_normed\_counts | DataFrame | $(G, \|\mathcal{L}_{\geq 3}\|)$ | For each gene $g$ and each level $l \in \mathcal{L}_{\geq 3}$, the corresponding entry $\overline{Z}^{\texttt{trim}}_{g,l}$ is the approximation of the trimmed mean of the normed counts for gene $g$ and samples whose line in the design corresponds to level $l$ with trim ratio $r_{\texttt{trim}}$, computed by summing the trimmed\_local\_sums and dividing by the sum of the local n\_samples for the corresponding gene and level. | Server | Center |
| 8 | use\_lvl | bool | $()$ | Whether or not to use the levels of the design matrix to compute the trimmed mean. If use\_lvl is $\texttt{True}$, then one trimmed mean of the squared errors will be computed for each gene and for each level of the design matrix (that is the trimmed mean will be performed on the samples corresponding to the same level of the design matrix across all centers). If use\_lvl is $\texttt{False}$, then one trimmed mean of the squared errors will be computed for each gene and for all samples. This parameter is set to $\texttt{True}$ if there is at least one level of the design matrix with more than 3 replicates across all centers, and to $\texttt{False}$ otherwise. | Each center | Server |
| 8 | $l \in \mathcal{L}_{\geq 3}$ | dict |  | Let $\mathcal{L}_{\geq 3}$ bet the set of levels $1 \leq l \leq L$ of the design matrix with at least $3$ replicates across all centers. Let $\mathcal{I}_{k,l}$ denote the set of sample indices $1 \leq i \leq n_k$ in center $k$ whose line in the design corresponds to level $l$. Let $R^{\texttt{trim}}_k$ be the matrix of square errors of size $(n,G)$ whose entries are $(Z^{(k)}_{ig} - \overline{Z}^{\texttt{trim}}_{g,l})^2$ if $i \in \mathcal{I}_{k,l}$ for some $l \in \mathcal{L}_{\geq 3}$ and $\texttt{nan}$ otherwise, for $1 \leq i\leq n_k$ and $1 \leq g \leq G$. Dictionary with two keys. <br> "max\_values", which is a numpy array of shape $G$ containing, for each gene $g$, the maximum value of the center squared errors for $g$ on samples in $\mathcal{I}_{k,l}$, denoted with $R^{\texttt{max}}_{k,g,l}$. <br> "min\_values", which is a numpy array of shape $G$ containing, for each gene $g$, the minimum value of the center squared errors for $g$ on samples in $\mathcal{I}_{k,l}$, denoted with $R^{\texttt{min}}_{k,g,l}$. | Each center | Server |
| 9 | use\_lvl | bool | $()$ | Whether or not to use the levels of the design matrix to compute the trimmed mean. Passed on without modification. | Server | Center |
| 9 | $l \in \mathcal{L}_{\geq 3}$ | dict |  | Dictionary with two keys. <br> "upper\_bounds\_thresholds" is a numpy array of shape $(G, 2)$. For each gene $g$ and for each ratio $r \in \{r_{\texttt{trim}}, 1 - r_{\texttt{trim}}\}$, will contain an upper bound of the $r$-quantile value of the squared errors of gene $g$ across samples in level $l$. Initialized for both ratios as the maximum of the squared errors of gene $g$ across all samples in level $l$, computed as $\max_k R^{\texttt{max}}_{k,g,l}$. <br> "lower\_bounds\_thresholds" is a numpy array of shape $(G, 2)$. For each gene $g$ and for each ratio $r \in \{r_{\texttt{trim}}, 1 - r_{\texttt{trim}}\}$, will contain a lower bound of the $r$-quantile value of the squared errors of gene $g$ across samples in level $l$. Initialized for both ratios as the minimum of the squared errors of gene $g$ across all samples in level $l$, computed as $\min_k R^{\texttt{min}}_{k,g,l}$. | Server | Center |
| 10 | $l \in \mathcal{L}_{\geq 3}$ | dict |  | Dictionary with the following keys. <br> "num\_strictly\_above" is a numpy array of shape $(G, 2)$. For each gene $g$ and each ratio $r$, contains the number of samples in the center and in the level whose squared errors value for gene $g$ is strictly above the average of the upper and lower  bounds on the $r$-quantile value of gene $g$. <br> "upper\_bounds\_thresholds" is a numpy array of shape $(G, 2)$, simply passed on from the previous state. <br> "lower\_bounds\_thresholds" is a numpy array of shape $(G, 2)$ simply passed on from the previous state. <br> "n\_samples" is the number of samples in level $l$ and center $k$. <br> "trim\_ratio" is the trim ration, defining the upper and lower ratios whose quantile we want to compute. Denoted with $r_{\texttt{trim}}$, equal to $0.125$. | Each center | Server |
| 10 | use\_lvl | bool | $()$ | Whether or not to use the levels of the design matrix to compute the trimmed mean. Passed on without modification. | Each center | Server |
| 11 | $l \in \mathcal{L}_{\geq 3}$ | dict |  | Dictionary with two keys. <br> "upper\_bounds\_thresholds" is a numpy array of shape $(G, 2)$. For each gene $g$ and for each ratio $r \in \{r_{\texttt{trim}}, 1 - r_{\texttt{trim}}\}$, contains an updated upper bound of the $r$-quantile value of the squared errors of gene $g$ across samples in level $l$. For a given gene $g$ and $r$-quantile, it is updated as either its previous value or the average of the previous upper and lower bounds across samples in level $l$, depending on the number of samples in the level whose squared errors value is strictly above this average. This number of samples can be computed from the previous shared states. <br> "lower\_bounds\_thresholds" is a numpy array of shape $(G, 2)$. For each gene $g$ and for each ratio $r \in \{r_{\texttt{trim}}, 1 - r_{\texttt{trim}}\}$, contains an updated lower bound of the $r$-quantile value of the squared errors of gene $g$ across samples in level $l$. For a given gene $g$ and $r$-quantile, it is updated as either its previous value or the average of the previous upper and lower bounds across samples in level $l$, depending on the number of samples in the level whose squared errors value is strictly above this average. This number of samples can be computed from the previous shared states. | Server | Center |
| 11 | use\_lvl | bool | $()$ | Whether or not to use the levels of the design matrix to compute the trimmed mean. Passed on without modification. | Server | Center |
| 12 | $l \in \mathcal{L}_{\geq 3}$ | dict |  | Dictionary with the following keys. <br> "trimmed\_local\_sum" is a numpy array of shape $(G,)$. For each gene $g$ and each ration $r \in \{r_{\texttt{trim}}, 1 - r_{\texttt{trim}}\}$, we approximate the $r$-quantile by taking the average of the running upper and lower bounds. The trimmed local sum is computed as the sum of the squared errors across all samples in level $l$ and center $k$, whose value is strictly above the approximation of the $r_{\texttt{trim}}$-quantile and less or equal to the approximation of the $1-r_{\texttt{trim}}$ quantile. <br> "n\_samples" is the number of samples in level $l$ and center $k$. <br> "num\_strictly\_above" is a numpy array of shape $(G, 2)$. For each gene $g$ and each ratio $r$, contains the number of samples in the center and in the level whose squared errors value for gene $g$ is strictly above the approximation of the $r$-quantile. <br> "upper\_bounds\_thresholds" is a numpy array of shape $(G, 2)$, simply passed on from the previous state. <br> "lower\_bounds\_thresholds" is a numpy array of shape $(G, 2)$ simply passed on from the previous state. "trim\_ratio", equal to $0.125$. <br> "scale", equal to $1.51$. | Each center | Server |
| 12 | use\_lvl | bool | $()$ | Whether or not to use the levels of the design matrix to compute the trimmed mean. Passed on without modification. | Each center | Server |
| 13 | varEst | nparray | $(G,)$ | For each gene $g$, the trimmed variance estimate of the normed counts, denoted with $V^{\texttt{trim}}_g$. If use\_lvl is $\texttt{True}$, for each gene $g$, it is the maximum across all admissible levels of the trimmed mean of the squared error for the gene and level in question, with trim ratio $r_{\texttt{trim}}$, scaled (multiplied) by the scale factor $1.51$. If use\_level is $\texttt{False}$, the trimmed mean of the squared error scaled by $1.51$ with trim ratio $r_{\texttt{trim}}$. | Server | Center |
| 14 | \_skip\_cooks | bool |  | A boolean indicating whether to skip the computation of the intermediate quantities to compute the  of the Cook's distance. This is set to $\texttt{True}$ if the Cook's distance is stored in the local state (which is not the case by default due to memory issues). Otherwise, it is set to $\texttt{False}$ (default behaviour). | Each center | Server |
| 14 | varEst | nparray | $(G,)$ | For each gene $g$, the trimmed variance estimate of the normed counts, denoted with $V^{\texttt{trim}}_g$. This quantitiy is passed on from the previous shared state. | Each center | Server |
| 14 | mean\_normed\_counts | nparray | $(G,)$ | For each gene, the mean of the local normed counts, i.e., $\overline{Z}^{(k)}_{g} = \tfrac{1}{n_k}\sum_{i=1}^{n_k}{Z^{(k)}_{ig}}$. | Each center | Server |
| 14 | local\_hat\_matrix | nparray | $(G_{\texttt{nz}}, p, p)$ | For each gene $g$, the hat matrix  $H^{(k)}_{g} = (X^{(k)})^{\top} W^{(k)}_g X^{(k)}$ where $W^{(k)}_g \in \mathbb{R}^{n_k \times n_k}$ is the diagonal matrix with diagonal entries $\frac{\mu^{(k)}_{ig}}{1 + \mu^{(k)}_{ig} \alpha_g}$ for $1 \leq i \leq n_k$. $\alpha_g$ is the dispersion estimate of the gene and $\mu^{(k)}_{ig}$ is the expected value of the gene for sample $i$ for parameter $\beta$, that is $\gamma^{(k)}_{g} \exp(X^{(k)}_{i} \cdot \beta_g)$. | Each center | Server |
| 14 | n\_samples | int |  | The number of samples in a center $n_k$ for each center $k$. | Each center | Server |
| 15 | cooks\_dispersions | nparray | $(G,)$ | For each gene $g$, a robust estimate of the dispersion parameter $\alpha^{\texttt{cooks}}_g$ computed from the trimmed variance estimate and the global mean of the normed counts. We compute this estimate as $\max((V^{\texttt{trim}}_g- \overline{Y}_g)/\overline{Y}_g^2,0.04)$. | Server | Center |
| 15 | global\_hat\_matrix\_inv | nparray | $(G_{\texttt{nz}}, p, p)$ | For each gene $g$, we compute the global hat matrix as the sum of the local hat matrices, and its inverse. | Server | Center |
